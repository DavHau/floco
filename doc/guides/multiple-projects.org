#+TITLE: Multiple Projects

=floco= was designed to make managing multiple local projects
easy, in fact it was originally designed to allow "recursive
local builds" in a way that =yarn= and =npm= really struggle
to provide.

The summary of this article for a =project-a= that depends on
=project-b= is basically:
#+BEGIN_SRC nix
{
  _file   = "project-a/floco-cfg.nix";
  imports = [
    ./pdefs.nix
    ./foverrides.nix
    ../project-b/floco-cfg.nix
  ];
}
#+END_SRC

* Files

The convention of organizating generated configs in
=pdefs.{json,nix}=, manual configuration in =foverrides.nix=,
and project/file organization in =floco-cfg.nix=
is recommended.

** =_file= Field

While the =_file= field is optional, it is strongly 
recommended and the modules for certain records are sensitive
to filenames.
By setting =_file= explicitly you'll ensure that backtraces
and deserialization of configs use the given name regardless
of the "real" filename which can help avoid pitfalls.
 
The files =floco-cfg.{nix,json}=, =pdefs.{nix,json}=, and
=foverrides.{nix,json}= specifically are treated specifically.
At time of writing only the =pdef= record is sensitive to
filenames, but more
[[https://github.com/aakropotkin/floco/blob/main/modules/records/pdef/implementation.nix#L76][deserialized]]
sensitive records may be added in the future.

For JSON files or other non-nix formats you must explicitly
set =_file= in an inline module.
The routine =lib.modules.importJSON= is a shorthand for this,
but the following two includes are equivalent:
#+BEGIN_SRC nix
{
  _file = "foo/floco-cfg.nix";
  imports = [
    ( { _file = ./foo/pdefs.json; } //
      ( lib.importJSON ./pdefs.json ) )
      
    ( lib.modules.importJSON ./foverrides.json )
  ];
}
#+END_SRC

When including JSON and other formats you should remember
the way "shorthand" configs get processed and you make
sure that you don't accidentally define
~config.config.foo = 1;~.

** =imports= Field

Imports are a module field containing paths to or inline
definitions of modules that will be merged with the
current module.

This field is special in the module system because it must
be processed before =config= and generally cannot refer
to any arguments other than =lib=.
=deferredModule= is an exception to this rule, and is
used to define configurable records.

=imports= may be defined for submodules as well, not just
the top level module.
This can be useful for recycling common code to be applied
to =pdef= or =package= records.


* Merged Build Plan

When multiple files or projects are combined with =imports=
the module system merges definitions of attrsets and types
recursively using rules defined in options' type definitions.

The
[[https://nixos.org/manual/nixos/stable/#sec-writing-modules][NixOS manual]]
is the best resource for learning about
merges, but I cover some fundamentals and notable types
in =floco= that use custom merge routines in the
[[https://github.com/aakropotkin/floco/blob/main/doc/guides/module-system.org][Module System]]
guide.
This section will assume that you have already made yourself familiar with
how configurations are merged "generally" and "priorities".

** Handling Conflicts

When combining multiple projects' generated configs the most common area to
run into conflicting metadata is in =depInfo.<IDENT>.pin= fields.
Other fields to watch out for are =fetchInfo.path=, =treeInfo=, =ltype=,
and =depInfo=.

*** Merging =depInfo.<IDENT>.pin= Definitions

This type has a custom =merge= function which breaks conflicts by
preferring the "highest" semantic version number.

These pins may be used by submodules that attempt to generate =treeInfo=
records when they are undefined, but remember that they will NOT have any
effect on configurations which explicitly define =treeInfo= records since
the generated fallbacks carry a low priority.

These conflicts are the most common because =pdefs.nix= files generated
from =package-lock.json= files are going to "pin" whatever =npm install=
resolves on a particular day.
Notably, the updater =fromPlock= will use an existing =package-lock.json=
if it exists, only adding missing lockfile entries, so one strategy for
avoiding conflicting pins is to check your =package-lock.json= into
version control, allowing it to be reprocessed by =fromPlock= when you
make changes to your dependency graph.


*** Merging =fetchInfo.path= Definitions

Because =fetchInfo.path= needs to resolve relative paths from the file
they are declared in, it uses a custom type which merges defintions with
the routine
[[https://github.com/aakropotkin/floco/blob/main/lib/options.nix#L23][mergeRelativePathOption]],
resolving relative paths to be absolute first, then asserts that all
definitions are equal ( using =mergeEqualOptions= ).

You can use this =merge= implementation, and refer its usage in
[[https://github.com/aakropotkin/floco/blob/main/modules/fetchers/path/implementation.nix#L101][<floco>/modules/fetchers/path/implementation.nix]]
if you need to use a similar relative path type in an extension
to =floco=.


*** Merging =ltype= Definitions

=ltype= is short for "Lifecycle Type", and is used to identify the
state of project in the preparation process based on the type of source
it is consumed from.

For example, when we consume a dependency as a tarball
( ~ltype = "file"~ ), we know that the project has already run any =build=
phases, and there is no need to rerun them.
This also means we do not care about the =devDependencies= for this
pacakge, and can ignore them; in fact, you may notice that =npm= and
=yarn= completely omit information related to =devDependencies= from
their lockfiles.

In cases where multiple =ltype= definitions are found, =floco= will choose
the "most prepared" definition so that other derived config values can
skip generating =treeInfo= records with =devDependencies=, and =package=
targets related to pre-distribution phases
( =built=, =lint=, and =test= ).

The priority is:
- =file= :: a distributed tarball.
- =dir= :: a local directory.
- =link= :: a symlink to a local directory, for =floco= this is effectively equivalent to =dir=.
- =git= :: a git checkout.


*** Merging =treeInfo= Definitions

=treeInfo= uses a regular =lib.types.lazyAttrsOf= type for its members,
and you should remember this when making these declarations.

It is strongly recommended that you only create a single =treeInfo=
definition for each project across all configs.
Using =lib.mkForce= in =foverrides.nix= can be a good way deal to with
any problematic =treeInfo= defintions in generated files or projects
that you import.

Note that the fallback trees used if no =treeInfo= record is defined are
produced from =depInfo.<IDENT>.pin= definitions.
See the section above that focuses on how these are merged.

A dedicated section below covers strategies for generating =treeInfo=
definitions with multiple projects.


* =treeInfo= Generation Strategies

The =treeInfo= record is used to define the filesystem hierarchy of the
=node_modules/= tree used for various preparation stages.
This is practically the most important part of =pdef= record, and
understanding the various strategies used to generate them can have a large
impact on build performance.

We'll start with a short summary of "install strategies" used by =npm= and
=yarn= to provide context for the strategies used in =floco=.


** Install Strategies in Other Tools

=npm= and =yarn= install strategies are a useful foundation to understand.
We'll start by describing non-workspace strategies first ignoring symlinks.

*** Nested

- Description :: Every direct dependency is placed in then =node_modules/= subdir of every consumer.

- Cycle Breaking :: A symlink to a parent may be added to =node_modules/<IDENT>= to break cycles.

- Pros
  + Easy to move modules around safely.

- Cons
  + Large number of redundant modules.
  + Breaks some bundlers and "source maps".


*** Hoisted

- Description :: Places transitive dependencies in root =node_modules/= directory if possible. Otherwise adds dependencies to subdirs of consumers.

- Cycle Breaking :: Hoisting largely eliminates the need to break cycles by relying on the Node.js resolution system. A cycle with the root package may cause a =node_modules/<IDENT>= symlink to be created - this requires cycle members to be copies.

- Pros
  + Significantly reduces redundant modules. Strongly preferred if modules are copied.
  + Reduces the risk of resolving different but compatible versions of a module in disparate parts of the =node_modules/= tree.
  + Source maps and bundlers "just work".

- Cons
  + Incredibly difficult to move modules.
  + Projects often forget to declare direct dependencies but avoid crashing because a sibling in the tree requested it.
    - This largely effects local projects; but it indirectly aggravates attempts by =floco= to run builds in isolation.
  + Large projects struggle to manage conflicting =peerDependency= requests properly.
    - This is completely manageable by folks with experience; but for beginners it's easy to make mistakes.


*** Shallow ( "Global" )

- Description :: A hybrid between "nested" and "hoisted" which only places direct dependencies in the root =node_modules/= directory, but uses the "hoisted" install strategy for subdirs. This strategy is equivalent to globally installing a module and copying/symlinking it into your =node_modules/= directory.

- Cycle Breaking :: Same idea as "hoisted".

- Pros
  + Easy to move trees.
  + Preserves some of the deduplication benefits seen in "hoisted".
  + When direct dependencies lack =peerDependencies=, symlinks to shared global installs are possible.

- Cons
  + Some modules are still duplicated, which may effect bundlers and "source maps".
  + Will not work if the root package fails to handle =peerDependencies= correctly.
  + If direct dependencies have =peerDependencies= they must be copied, not symlinked in order to resolve properly.
  + If tools literally copy/symlink from globally installed directories, compatibility between transitive dependencies can become an issue.


*** Plug and Play ( PnP )

- Description :: Essentially bundles dependencies into a single file, or uses source maps to refer to shared installs.

- Cycle Breaking :: Graph nodes are merged ( bundled ) into a common namespace, dissolving the issue of cycles altogether.

- Pros
  + Fixes a large number of issues with the fundamental design of the =node_modules/= approach to dependency management.
  + Source maps generally work ( PnP is basically a giant source map ).
  + Can deduplicate dependencies system/workspace wide by sharing a single copy. In this sense its very similar to the nested symlink strategy used by =floco=.

- Cons
  + Experimental, may not be ready for use in production code and not standardized.
  + Requires patching core parts of =node=. It's a wide sweeping change that may misbehave in unexpected ways.
  + Not supported or problematic with many common tools and libraries.
  + Struggles with sanitation of =*.node= bindings and platform portability ( =yarn= specifically ).
