#+TITLE: Multiple Projects

=floco= was designed to make managing multiple local projects
easy, in fact it was originally designed to allow "recursive
local builds" in a way that =yarn= and =npm= really struggle
to provide.

The summary of this article for a =project-a= that depends on
=project-b= is basically:
#+BEGIN_SRC nix
{
  _file   = "project-a/floco-cfg.nix";
  imports = [
    ./pdefs.nix
    ./foverrides.nix
    ../project-b/floco-cfg.nix
  ];
}
#+END_SRC

* Files

The convention of organizating generated configs in
=pdefs.{json,nix}=, manual configuration in =foverrides.nix=,
and project/file organization in =floco-cfg.nix=
is recommended.

** =_file= Field

While the =_file= field is optional, it is strongly 
recommended and the modules for certain records are sensitive
to filenames.
By setting =_file= explicitly you'll ensure that backtraces
and deserialization of configs use the given name regardless
of the "real" filename which can help avoid pitfalls.
 
The files =floco-cfg.{nix,json}=, =pdefs.{nix,json}=, and
=foverrides.{nix,json}= specifically are treated specifically.
At time of writing only the =pdef= record is sensitive to
filenames, but more
[[https://github.com/aakropotkin/floco/blob/main/modules/records/pdef/implementation.nix#L76][deserialized]]
sensitive records may be added in the future.

For JSON files or other non-nix formats you must explicitly
set =_file= in an inline module.
The routine =lib.modules.importJSON= is a shorthand for this,
but the following two includes are equivalent:
#+BEGIN_SRC nix
{
  _file = "foo/floco-cfg.nix";
  imports = [
    ( { _file = ./foo/pdefs.json; } //
      ( lib.importJSON ./pdefs.json ) )
      
    ( lib.modules.importJSON ./foverrides.json )
  ];
}
#+END_SRC

When including JSON and other formats you should remember
the way "shorthand" configs get processed and you make
sure that you don't accidentally define
~config.config.foo = 1;~.

** =imports= Field

Imports are a module field containing paths to or inline
definitions of modules that will be merged with the
current module.

This field is special in the module system because it must
be processed before =config= and generally cannot refer
to any arguments other than =lib=.
=deferredModule= is an exception to this rule, and is
used to define configurable records.

=imports= may be defined for submodules as well, not just
the top level module.
This can be useful for recycling common code to be applied
to =pdef= or =package= records.


* Merged Build Plan

When multiple files or projects are combined with =imports=
the module system merges definitions of attrsets and types
recursively using rules defined in options' type definitions.

The
[[https://nixos.org/manual/nixos/stable/#sec-writing-modules][NixOS manual]]
is the best resource for learning about
merges, but I cover some fundamentals and notable types
in =floco= that use custom merge routines in the
[[https://github.com/aakropotkin/floco/blob/main/doc/guides/module-system.org][Module System]]
guide.
This section will assume that you have already made yourself familiar with
how configurations are merged "generally" and "priorities".

** Handling Conflicts

When combining multiple projects' generated configs the most common area to
run into conflicting metadata is in =depInfo.<IDENT>.pin= fields.
Other fields to watch out for are =fetchInfo.path=, =treeInfo=, =ltype=,
and =depInfo=.

*** Merging =depInfo.<IDENT>.pin= Definitions

This type has a custom =merge= function which breaks conflicts by
preferring the "highest" semantic version number.

These pins may be used by submodules that attempt to generate =treeInfo=
records when they are undefined, but remember that they will NOT have any
effect on configurations which explicitly define =treeInfo= records since
the generated fallbacks carry a low priority.

These conflicts are the most common because =pdefs.nix= files generated
from =package-lock.json= files are going to "pin" whatever =npm install=
resolves on a particular day.
Notably, the updater =fromPlock= will use an existing =package-lock.json=
if it exists, only adding missing lockfile entries, so one strategy for
avoiding conflicting pins is to check your =package-lock.json= into
version control, allowing it to be reprocessed by =fromPlock= when you
make changes to your dependency graph.


*** Merging =fetchInfo.path= Definitions

Because =fetchInfo.path= needs to resolve relative paths from the file
they are declared in, it uses a custom type which merges defintions with
the routine
[[https://github.com/aakropotkin/floco/blob/main/lib/options.nix#L23][mergeRelativePathOption]],
resolving relative paths to be absolute first, then asserts that all
definitions are equal ( using =mergeEqualOptions= ).

You can use this =merge= implementation, and refer its usage in
[[https://github.com/aakropotkin/floco/blob/main/modules/fetchers/path/implementation.nix#L101][<floco>/modules/fetchers/path/implementation.nix]]
if you need to use a similar relative path type in an extension
to =floco=.


*** Merging =ltype= Definitions

=ltype= is short for "Lifecycle Type", and is used to identify the
state of project in the preparation process based on the type of source
it is consumed from.

For example, when we consume a dependency as a tarball
( ~ltype = "file"~ ), we know that the project has already run any =build=
phases, and there is no need to rerun them.
This also means we do not care about the =devDependencies= for this
pacakge, and can ignore them; in fact, you may notice that =npm= and
=yarn= completely omit information related to =devDependencies= from
their lockfiles.

In cases where multiple =ltype= definitions are found, =floco= will choose
the "most prepared" definition so that other derived config values can
skip generating =treeInfo= records with =devDependencies=, and =package=
targets related to pre-distribution phases
( =built=, =lint=, and =test= ).

The priority is:
- =file= :: a distributed tarball.
- =dir= :: a local directory.
- =link= :: a symlink to a local directory, for =floco= this is effectively equivalent to =dir=.
- =git= :: a git checkout.


*** Merging =treeInfo= Definitions

=treeInfo= uses a regular =lib.types.lazyAttrsOf= type for its members,
and you should remember this when making these declarations.

It is strongly recommended that you only create a single =treeInfo=
definition for each project across all configs.
Using =lib.mkForce= in =foverrides.nix= can be a good way deal to with
any problematic =treeInfo= defintions in generated files or projects
that you import.

Note that the fallback trees used if no =treeInfo= record is defined are
produced from =depInfo.<IDENT>.pin= definitions.
See the section above that focuses on how these are merged.

A dedicated section below covers strategies for generating =treeInfo=
definitions with multiple projects.


* =treeInfo= Generation Strategies

The =treeInfo= record is used to define the filesystem hierarchy of the
=node_modules/= tree used for various preparation stages.
This is practically the most important part of =pdef= record, and
understanding the various strategies used to generate them can have a large
impact on build performance.

We'll start with a short summary of "install strategies" used by =npm= and
=yarn= to provide context for the strategies used in =floco=.


** Install Strategies in Other Tools

=npm= and =yarn= install strategies are a useful foundation to understand.


*** Nested

- Description :: Every direct dependency is placed in then =node_modules/= subdir of every consumer.

- Cycle Breaking :: A symlink to a parent may be added to =node_modules/<IDENT>= to break cycles.

- Pros
  + Easy to move modules around safely.

- Cons
  + Large number of redundant modules.
  + Breaks some bundlers and "source maps".


*** Hoisted

- Description :: Places transitive dependencies in root =node_modules/= directory if possible. Otherwise adds dependencies to subdirs of consumers.

- Cycle Breaking :: Hoisting largely eliminates the need to break cycles by relying on the Node.js resolution system. A cycle with the root package may cause a =node_modules/<IDENT>= symlink to be created - this requires cycle members to be copies.

- Pros
  + Significantly reduces redundant modules. Strongly preferred if modules
    are copied.
  + Reduces the risk of resolving different but compatible versions of a
    module in disparate parts of the =node_modules/= tree.
  + Source maps and bundlers "just work".

- Cons
  + Incredibly difficult to move modules.
  + Projects often forget to declare direct dependencies but avoid
    crashing because a sibling in the tree requested it.
    - This largely effects local projects; but it indirectly aggravates
      attempts by =floco= to run builds in isolation.
  + Large projects struggle to manage conflicting =peerDependency=
    requests properly.
    - This is completely manageable by folks with experience; but for
      beginners it's easy to make mistakes.


*** Shallow ( "Global" )

- Description :: A hybrid between "nested" and "hoisted" which only places direct dependencies in the root =node_modules/= directory, but uses the "hoisted" install strategy for subdirs. This strategy is equivalent to globally installing a module and copying/symlinking it into your =node_modules/= directory.

- Cycle Breaking :: Same idea as "hoisted".

- Pros
  + Easy to move trees.
  + Preserves some of the deduplication benefits seen in "hoisted".
  + When direct dependencies lack =peerDependencies=, symlinks to shared
    global installs are possible.

- Cons
  + Some modules are still duplicated, which may effect bundlers and
    "source maps".
  + Will not work if the root package fails to handle
    =peerDependencies= correctly.
  + If direct dependencies have =peerDependencies= they must be copied,
    not symlinked in order to resolve properly.
  + If tools literally copy/symlink from globally installed directories,
    compatibility between transitive dependencies can become an issue.


*** Plug and Play ( PnP )

- Description :: Essentially bundles dependencies into a single file, or uses source maps to refer to shared installs.

- Cycle Breaking :: Graph nodes are merged ( bundled ) into a common namespace, dissolving the issue of cycles altogether.

- Pros
  + Fixes a large number of issues with the fundamental design of the
    =node_modules/= approach to dependency management.
  + Source maps generally work ( PnP is basically a giant source map ).
  + Can deduplicate dependencies system/workspace wide by sharing a
    single copy.
    - Very similar to the nested symlink strategy used by =floco=.

- Cons
  + Experimental, may not be ready for use in production code and
    not standardized.
  + Requires patching core parts of =node=. It's a wide sweeping change
    that may misbehave in unexpected ways.
  + Not supported or problematic with many common tools and libraries.
  + Struggles with sanitation of =*.node= bindings and platform
    portability ( =yarn= specifically ).


*** Workspaces

- Description :: Groups of projects share =node_modules/= directories placed in parent directories. Similar to "hoisted" strategy, except =devDependencies= of workspace members can be installed. Symlinks are used to resolve.

- Cycle Breaking :: Same idea as "hoisted".

- Pros
  + Improves on the deduplication benefits of "hoisted".
  + Further reduces the risk of "compatible but different version"
    resolution for workspace members.

- Cons
  + Implementations by =yarn= and =npm= feel experimental in quality.
    - Difficult to debug.
    - Conflicting lockfiles and unexpected effects of an existing
      =node_modules/= tree on the filesystem make it easy to shoot your
      foot off.
  + Further aggravates issues related to =peerDependencies= that effect
    "hoisted" strategy, especially concerning =devDependencies=.
  + No standardized way to drive/order builds among workspace members.
    - =npm= doesn't support his at all, and =yarn= attempts to support
      this are fraught.
  + Installing closures and subtrees is difficult and buggy.
    - Running builds in isolation is aggravated.


** =treeInfo= Requirements

The =treeInfo= scheme strictly works with subtrees placed in the
=node_modules/= directory of "the project being built", so "workspaces"
with dependencies placed in parent directories must be moved into subdirs,
and pruned to contain only the closure of packages required for a particular
preparation stage.

Symlinks to other projects point to the globally installed form of a package
so any projects with =peerDependencies= are not suitable candidates for
symlinking unless they also directly depend on the same version of a
dependency marked as a peer.
=treeInfo= paths marked for symlinking must not declare any subpaths.
If dependency cycles exist between packages it is necessary to break these
cycles by explicitly declaring at least one =treeInfo= member in such a way
that copies are used to avoid two global installs from depending on
one another.

The =optional= and =devOptional= fields are interpreted as applying only to
the path that sets them.
Subpaths do not automatically inherit these settings.
( TODO: Fix this ).


** Scraping =treeInfo= from =package-lock.json= (v2/3)

This is currently the recommended method of creating =treeInfo= records for
a project and is the process used by both the =fromPlock= and =fromRegistry=
"updaters" to produce =pdefs.{nix,json}= files.

Inclusion of the root project's =treeInfo=, as well as =depInfo.<IDENT>.pin=
fields can be enabled/disabled using the flags =--[no-]tree=
and =--[no-]pins=.
We'll cover when you might prefer each combination of flags in the sections
below.

*** =npm= Install Strategy Flags
In the case of =fromPlock= it's possible to pass additional flags to =npm=
such as ~--install-strategy=(nested|hoisted|shallow)~
( defaults to =hoisted= ), as well as
~--workspaces=(true|false)~ ( defaults to =true= ), and
=--legacy-peer-deps= ( not recommended ) if it is necessary.

Folks working with multiple local projects may find the argument
=--install-links= useful to force references to local paths to be treated
as tarballs ( ~ltype = "file";~ ).
This will ensure that you get the runtime dependencies of those projects
in your =treeInfo= record without a ~link = true;~ field.

For =fromRegistry= we use ~--install-strategy=shallow~ with
=--legacy-peer-deps= on a dummy project, and extract the subtree placed
under =node_modules/<IDENT>=.
While you can manually set ~--install-strategy=nested~ if desired, you
shouldn't use "hoisted" because you'll end up with an empty subtree.

Note that we do not recommend using =fromPlock= with workspaces for
generating =treeInfo= records unless you understand that they require
post-processing to "focus" them into subtrees.


** Scraping =depInfo.<IDENT>.pin= from =yarn.lock= (v5)

There is a functional, but experimental =yarn.lock= translator that can
provide pins and =pdefs= ( but not =treeInfo= ).

We won't cover it's usage in detail here because it is going to be
refactored soon; but for those who want to use it now it is located under
[[https://github.com/aakropotkin/floco/modules/ylockToPdefs/implementation.nix][<floco>/modules/ylockToPdefs/implementation.nix]].
This file is a regular function ( which is why it needs a rewrite ) which
takes =lockDir=, =pkgs= ( for =yq= ), and =lib= as arguments.

You'll be relying on the global symlink strategy ( described in the next
section ) to produce trees unless you provide explicit definitions, so
you'll need to deal with cycles in transitive dependencies by using
=fromRegistry= to generate those =treeInfo= records
( which can be imported or copy/pasted ).


** Deriving =treeInfo= from Pins

I'll preface this section by saying that a routine which produces hoisted
=treeInfo= records from pins is currently being written ( currently works
but doesn't mark =optional=, =dev=, or =devOptional= fields ).
Until this routine is complete the only trees we can derive from pins are
"shallow" trees using symlinks to globally installed forms of depdencies.

This "shallow links" strategy is great for local development, but will not
behave correctly for =peerDependencies= declared in your direct depencies,
so you'll need to use =fromRegistry -- --tree= or =fromPlock -- --tree= in
those cases.
